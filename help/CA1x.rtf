{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Light;\f1\fnil\fcharset0 HelveticaNeue;\f2\fswiss\fcharset0 Helvetica;
\f3\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red0\green77\blue204;\red96\green96\blue96;\red204\green0\blue102;
}
\deftab560
\pard\pardeftab560\ql\qnatural

\f0\fs140 \cf2 CA1x
\f1 \cf0 \
\pard\pardeftab560\ql\qnatural

\f2\b\fs24 \cf0 *ar(smprt, smpwd, rule, seed, trig, mul, add)
\b0 \
ugen one-dimensional binary state cellular automaton. \
calculates the lattice's mean density to generate sample values.\
cubic-interpolation.\
\

\b smprt	
\b0 iteration frequency\

\b smpwd
\b0  	lattice size\

\b rule	
\b0 	0-255\

\b seed
\b0 	seeding ( random if \cf3 0\cf0 , otherwise translate integers into binary )\

\b trig	
\b0 	retrigger\
\pard\pardeftab560\ql\qnatural

\f3\fs18 \cf0 \
\
\pard\pardeftab560\ql\qnatural
\cf4 //see what the rule generate\cf0 \
\cf3 105\cf0 .asCA;\
\cf4 \
//this is then translated as waveform\cf0 \
\{ \cf2 CA1x\cf0 .ar(\cf3 10000\cf0 , \cf3 50\cf0 , \cf3 105\cf0 , mul: \cf3 0.5\cf0 ).dup \}.play;\
\cf4 \
//change the lattice size, move mouse up/down\cf0 \
\{ \cf2 CA1x\cf0 .ar(\cf3 10000\cf0 , \cf2 MouseY\cf0 .kr(\cf3 16\cf0 , \cf3 100\cf0 ), \cf3 105\cf0 , mul: \cf3 0.5\cf0 ).dup \}.play;\
\cf4 \
// rule 110... short sound\cf0 \
\{ \cf2 CA1x\cf0 .ar(\cf3 2000\cf0 , \cf3 160\cf0 , \cf3 110\cf0 , \cf3 1\cf0 , mul: \cf3 0.5\cf0 ).dup \}.play;\
\cf4 \
// restimulate, move mouse up/down\cf0 \
\{ \cf2 CA1x\cf0 .ar(\cf3 2000\cf0 , \cf2 MouseY\cf0 .kr(\cf3 16\cf0 , \cf3 100\cf0 ), \cf3 110\cf0 , \cf3 1\cf0 , \cf2 Impulse\cf0 .kr(\cf3 10\cf0 ), mul: \cf3 0.5\cf0 ).dup \}.play;\
\cf4 \
// seeding, move mouse up/down and left/right\cf0 \
\{ \cf2 CA1x\cf0 .ar(\cf3 2000\cf0 , \cf2 MouseY\cf0 .kr(\cf3 16\cf0 , \cf3 200\cf0 ), \cf3 110\cf0 , \cf2 MouseX\cf0 .kr(\cf3 0\cf0 , \cf3 255\cf0 ).round(1), \cf2 Impulse\cf0 .kr(\cf3 10\cf0 ), \cf3 0.5\cf0 ).dup \}.play;}